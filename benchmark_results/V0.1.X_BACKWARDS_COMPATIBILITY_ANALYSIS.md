# v0.1.x → v2.5 Backwards Compatibility Analysis
**Date**: October 28, 2025
**Critical Discovery**: v0.1.x HAD these features, v2.5 REMOVED them!

## Executive Summary

**CRITICAL FINDING**: The user was RIGHT! v0.1.x **DID** have `tiers`, `workflows`, `enable_caching`, and `enable_callbacks` parameters. These were **REMOVED** in v2.5, breaking backwards compatibility.

**Git Evidence**: Commit `61b71a8` shows the old implementation with all these features.

---

## v0.1.x API (What Existed)

### CascadeAgent.__init__() Signature

```python
# v0.1.x (commit 61b71a8)
def __init__(
    self,
    models: List[ModelConfig],
    config: Optional[CascadeConfig] = None,
    tiers: Optional[Dict[str, UserTier]] = None,  # ✅ EXISTED
    workflows: Optional[Dict[str, WorkflowProfile]] = None,  # ✅ EXISTED
    enable_caching: bool = False,  # ✅ EXISTED
    cache_size: int = 1000,  # ✅ EXISTED
    enable_callbacks: bool = True,  # ✅ EXISTED
    verbose: bool = False
):
```

### What v0.1.x Implemented

#### 1. User Tiers ✅ FULLY IMPLEMENTED

**Class Definition** (`cascadeflow/config.py`):
```python
class UserTier(BaseModel):
    """Dynamic user tier with latency awareness."""
    name: str
    latency: LatencyProfile  # Max latency constraints
    optimization: OptimizationWeights  # cost/speed/quality weights
    max_budget: Optional[float]  # Budget limit per query
    quality_threshold: float  # Min quality requirement
    max_concurrent: int  # Max parallel queries
    description: Optional[str]
```

**Default Tiers**:
```python
DEFAULT_TIERS = {
    "free": UserTier(
        name="free",
        latency=LatencyProfile(max_total_ms=15000, ...),
        optimization=OptimizationWeights(cost=0.70, speed=0.15, quality=0.15),
        max_budget=0.001,
        quality_threshold=0.65,
        max_concurrent=2,
    ),
    "pro": UserTier(
        name="pro",
        latency=LatencyProfile(max_total_ms=5000, ...),
        optimization=OptimizationWeights(cost=0.40, speed=0.30, quality=0.30),
        max_budget=0.01,
        quality_threshold=0.75,
        max_concurrent=5,
    ),
    "enterprise": UserTier(
        name="enterprise",
        latency=LatencyProfile(max_total_ms=3000, ...),
        optimization=OptimizationWeights(cost=0.20, speed=0.30, quality=0.50),
        max_budget=0.05,
        quality_threshold=0.85,
        max_concurrent=10,
    )
}
```

**Usage**:
```python
# v0.1.x
agent = CascadeAgent(models=[...], tiers=DEFAULT_TIERS)

result = await agent.run(
    query="...",
    user_tier="free"  # Applies free tier constraints
)
```

**Implementation**:
- Stored in `self.tiers`
- Used in `_filter_models()` to restrict model access
- Used in `_execute_plan()` to enforce budget/quality

#### 2. Workflows ✅ FULLY IMPLEMENTED

**Class Definition**:
```python
class WorkflowProfile(BaseModel):
    """Developer-defined workflow profiles for specific use cases."""
    name: str
    latency_override: Optional[LatencyProfile]
    optimization_override: Optional[OptimizationWeights]
    max_budget_override: Optional[float]
    quality_threshold_override: Optional[float]
    allowed_models: Optional[List[str]]
    description: Optional[str]
```

**Usage**:
```python
# v0.1.x
workflows = {
    "draft_mode": WorkflowProfile(
        name="draft_mode",
        max_budget_override=0.0001,
        quality_threshold_override=0.5,
        allowed_models=["llama-3.1-8b-instant"],
        description="Quick drafts"
    ),
    "medical_mode": WorkflowProfile(
        name="medical_mode",
        quality_threshold_override=0.9,
        allowed_models=["gpt-4", "claude-opus"],
        description="High-accuracy medical responses"
    )
}

agent = CascadeAgent(models=[...], workflows=workflows)

result = await agent.run(
    query="...",
    workflow="medical_mode"  # Applies medical workflow constraints
)
```

**Implementation**:
- Stored in `self.workflows`
- Used in `_filter_models()` to restrict model access
- Overrode tier settings when specified

#### 3. Caching ✅ FULLY IMPLEMENTED

**Class**: `ResponseCache`

**Implementation**:
```python
# v0.1.x agent.__init__
self.cache = ResponseCache(max_size=cache_size) if enable_caching else None

# In agent.run()
if self.cache:
    cached = self.cache.get(query)
    if cached:
        return cached  # Return cached response

# After execution
if self.cache:
    self.cache.set(query, result)
```

**Features**:
- LRU cache with configurable size
- Query-based cache key
- Automatic expiration

#### 4. Callbacks ✅ FULLY IMPLEMENTED

**Class**: `CallbackManager` (existed in v0.1.x)

**Implementation**:
```python
# v0.1.x agent.__init__
self.callback_manager = CallbackManager() if enable_callbacks else None

# Events triggered in v0.1.x:
- QUERY_START
- COMPLEXITY_DETECTED
- MODEL_SELECTED
- EXECUTION_START
- EXECUTION_COMPLETE
- CASCADE_DECISION
- CACHE_HIT / CACHE_MISS
- QUERY_COMPLETE
- QUERY_ERROR
```

**Usage**:
```python
# v0.1.x
def on_cascade(event_data):
    print(f"Cascaded from {event_data['from']} to {event_data['to']}")

agent = CascadeAgent(models=[...], enable_callbacks=True)
agent.callback_manager.register(CallbackEvent.CASCADE_DECISION, on_cascade)

result = await agent.run("...")  # Callback fires
```

---

## v2.5 API (Current - BREAKING CHANGES)

### CascadeAgent.__init__() Signature

```python
# v2.5 (current)
def __init__(
    self,
    models: list[ModelConfig],
    quality_config: Optional[QualityConfig] = None,  # NEW (replaces config)
    enable_cascade: bool = True,  # NEW
    verbose: bool = False,
    # ❌ REMOVED: tiers
    # ❌ REMOVED: workflows
    # ❌ REMOVED: enable_caching
    # ❌ REMOVED: cache_size
    # ❌ REMOVED: enable_callbacks
    # ❌ REMOVED: config
):
```

### What v2.5 Removed

1. ❌ **Tiers**: Complete removal, no tier system
2. ❌ **Workflows**: Complete removal, no workflow system
3. ❌ **Caching**: Complete removal, no caching system
4. ❌ **Callbacks**: CallbackManager class EXISTS but NOT wired to agent
5. ❌ **CascadeConfig**: Replaced with QualityConfig (different API)

### What v2.5 Added

1. ✅ **QualityConfig**: New quality validation system
2. ✅ **enable_cascade**: Explicit cascade control
3. ✅ **CostCalculator**: Cost tracking (but no enforcement)
4. ✅ **MetricsCollector**: Statistics tracking
5. ✅ **PreRouter**: Complexity-based routing
6. ✅ **ToolRouter**: Tool capability filtering
7. ✅ **TerminalVisualConsumer**: UI feedback

---

## Breaking Changes Summary

| Feature | v0.1.x | v2.5 | Status |
|---------|--------|------|--------|
| `tiers` parameter | ✅ Fully implemented | ❌ Removed | BREAKING |
| `workflows` parameter | ✅ Fully implemented | ❌ Removed | BREAKING |
| `enable_caching` | ✅ Fully implemented | ❌ Removed | BREAKING |
| `cache_size` | ✅ Fully implemented | ❌ Removed | BREAKING |
| `enable_callbacks` | ✅ Fully implemented | ⚠️ Not wired | BREAKING |
| `config` parameter | ✅ CascadeConfig | ✅ QualityConfig | CHANGED API |
| User tier enforcement | ✅ Working | ❌ None | BREAKING |
| Workflow profiles | ✅ Working | ❌ None | BREAKING |
| Response caching | ✅ Working | ❌ None | BREAKING |
| Callback events | ✅ Triggered | ❌ Not triggered | BREAKING |

---

## Impact on Existing Users

### Code that BREAKS in v2.5

```python
# v0.1.x code (BREAKS in v2.5)
from cascadeflow import CascadeAgent, DEFAULT_TIERS

agent = CascadeAgent(
    models=[...],
    tiers=DEFAULT_TIERS,  # ❌ TypeError: unexpected keyword argument
    enable_caching=True,  # ❌ TypeError: unexpected keyword argument
    enable_callbacks=True  # ❌ TypeError: unexpected keyword argument
)

# Tier-aware queries (BREAKS)
result = await agent.run("...", user_tier="free")  # ❌ user_tier not supported

# Workflow queries (BREAKS)
result = await agent.run("...", workflow="medical_mode")  # ❌ workflow not supported

# Callback access (BREAKS)
agent.callback_manager.register(...)  # ❌ AttributeError: no callback_manager

# Cache access (BREAKS)
stats = agent.cache.get_stats()  # ❌ AttributeError: no cache
```

---

## Backwards Compatibility Requirements

### Must Support (CRITICAL)

1. **Tiers** - Users depend on this for multi-tenant SaaS
2. **Workflows** - Users depend on this for specialized use cases
3. **Caching** - Users depend on this for cost optimization
4. **Callbacks** - Users depend on this for monitoring/logging

### Migration Path Needed

**Option A: Full Backwards Compatibility (RECOMMENDED)**
- Accept old parameters
- Map to new v2.5 architecture
- Provide deprecation warnings
- Maintain functionality

**Option B: Breaking Change**
- Remove old parameters entirely
- Force migration to v2.5 API
- Provide migration guide
- Risk losing users

---

## Recommended Implementation

### Phase 1: Accept Old Parameters (Backwards Compatibility)

```python
# cascadeflow/agent.py
class CascadeAgent:
    def __init__(
        self,
        models: list[ModelConfig],
        # NEW v2.5 parameters
        quality_config: Optional[QualityConfig] = None,
        enable_cascade: bool = True,
        verbose: bool = False,
        # OLD v0.1.x parameters (DEPRECATED but accepted)
        config: Optional[CascadeConfig] = None,  # DEPRECATED
        tiers: Optional[Dict[str, UserTier]] = None,  # DEPRECATED
        workflows: Optional[Dict[str, WorkflowProfile]] = None,  # DEPRECATED
        enable_caching: bool = False,  # DEPRECATED
        cache_size: int = 1000,  # DEPRECATED
        enable_callbacks: bool = True,  # DEPRECATED (but always enabled now)
    ):
        # Map old to new
        if config and not quality_config:
            quality_config = self._convert_cascade_config_to_quality_config(config)
            logger.warning(
                "Parameter 'config' is deprecated. Use 'quality_config' instead. "
                "This parameter will be removed in v0.3.0."
            )

        if tiers:
            logger.warning(
                "Parameter 'tiers' is deprecated. "
                "Use tier_router with enable_tier_routing=True instead. "
                "This parameter will be removed in v0.3.0."
            )
            self._legacy_tiers = tiers
            # Initialize tier router internally
            self.tier_router = self._create_tier_router_from_legacy_tiers(tiers)
            self.enable_tier_routing = True

        if workflows:
            logger.warning(
                "Parameter 'workflows' is deprecated. "
                "Use domain_strategies instead. "
                "This parameter will be removed in v0.3.0."
            )
            self._legacy_workflows = workflows

        if enable_caching:
            logger.warning(
                "Caching support is being re-implemented in v0.2.1. "
                "For now, caching is disabled."
            )
            # TODO: Implement caching in v0.2.1

        # Callbacks are always enabled now
        self.callback_manager = CallbackManager(verbose=verbose)
        if not enable_callbacks:
            logger.warning(
                "Callbacks are now always enabled. "
                "Use callback_manager.clear() to disable specific events."
            )

        # Continue with v2.5 initialization
        ...
```

### Phase 2: Implement Missing Features

1. **Tier Router** (map from old tiers)
2. **Workflow Profiles** (map to domain strategies)
3. **Response Cache** (re-implement)
4. **Wire Callbacks** (already exists, just needs wiring)

---

## Testing Strategy

### Backwards Compatibility Tests

```python
# tests/test_backwards_compatibility.py

def test_v0_1_x_tier_parameter():
    """Test that old tiers parameter still works."""
    from cascadeflow import CascadeAgent, DEFAULT_TIERS

    # Should NOT raise TypeError
    agent = CascadeAgent(
        models=[...],
        tiers=DEFAULT_TIERS  # OLD API
    )

    # Should warn about deprecation
    with pytest.warns(DeprecationWarning):
        agent = CascadeAgent(models=[...], tiers=DEFAULT_TIERS)

    # Should work functionally
    result = await agent.run("...", user_tier="free")
    assert result is not None

def test_v0_1_x_caching_parameter():
    """Test that old enable_caching parameter is accepted."""
    # Should NOT raise TypeError
    agent = CascadeAgent(
        models=[...],
        enable_caching=True  # OLD API
    )

    # Should warn
    with pytest.warns(DeprecationWarning):
        agent = CascadeAgent(models=[...], enable_caching=True)

def test_v0_1_x_callbacks_parameter():
    """Test that old enable_callbacks parameter works."""
    # Should NOT raise TypeError
    agent = CascadeAgent(
        models=[...],
        enable_callbacks=True  # OLD API
    )

    # Should have callback_manager
    assert agent.callback_manager is not None

def test_v0_1_x_full_api():
    """Test complete v0.1.x API still works."""
    agent = CascadeAgent(
        models=[...],
        tiers=DEFAULT_TIERS,
        workflows={"medical": ...},
        enable_caching=True,
        cache_size=500,
        enable_callbacks=True,
        verbose=True
    )

    result = await agent.run("...", user_tier="free", workflow="medical")
    assert result is not None
```

---

## Timeline

### Week 1: Backwards Compatibility Layer
1. Accept old parameters (2-3 hours)
2. Map tiers → tier_router (4-6 hours)
3. Map workflows → domain_strategies (3-4 hours)
4. Wire callbacks (4-6 hours)
5. Tests (4-6 hours)

**Total Week 1**: 17-25 hours

### Week 2: Re-implement Removed Features
1. ResponseCache (6-8 hours)
2. Enhanced tier enforcement (6-8 hours)
3. Workflow profile support (6-8 hours)
4. Tests (6-8 hours)

**Total Week 2**: 24-32 hours

### Week 3: Polish + New Features
1. Presets 2.0 (8-10 hours)
2. Domain cascading (10-12 hours)
3. Documentation (8-10 hours)
4. Migration guide (4-6 hours)

**Total Week 3**: 30-38 hours

**Grand Total**: 71-95 hours (9-12 days)

---

## Conclusion

**Status**: v2.5 introduced BREAKING CHANGES by removing v0.1.x features

**Impact**: Users upgrading from v0.1.x to v2.5 will experience:
- TypeError exceptions
- Loss of tier enforcement
- Loss of workflow profiles
- Loss of caching
- Loss of callback events

**Recommendation**: Implement full backwards compatibility layer (Phase 1) BEFORE any new features. This ensures v0.1.x users can upgrade to v2.5 without code changes.

**Priority Order**:
1. **P0** (CRITICAL): Accept old parameters without errors
2. **P0** (CRITICAL): Map tiers to new tier_router
3. **P0** (CRITICAL): Wire callbacks to agent
4. **P1** (HIGH): Re-implement caching
5. **P1** (HIGH): Map workflows to domain strategies
6. **P2** (NICE): New features (Presets 2.0, domain cascading)

**Next Action**: Update MASTER_IMPLEMENTATION_PLAN.md with backwards compatibility as P0 priority.
